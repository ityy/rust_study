//! 字符串
//! 字符串编码
//!     ASCII码，占用7bit，1byte，2位十六进制数即可表示：0x00-0x7F。可容乃128个字符，涵盖了英文字母，数字，常用符号，控制符号等。
//!     各国基于ASCII码扩展了自己的编码，但导致的问题是一但跨国，就会出现乱码，因为编码被重复定义了。
//!     为了解决这个问题，让世界上的所有符号文字都有一个世界唯一的编码，Unicode诞生了。
//! Unicode数字编码
//!     Unicode占用2-4个字节，基本给全世界的文字和符号都定义了一个唯一的数字编码，称为码点。分别使用u+9053或u-99005533的形式标记。
//!     Unicode仅定义了码点，对存储不做规定。且直接存储码点太占用空间，UTF-8随之诞生。
//! UTF-8传输编码
//!     UTF-8是对Unicode码点的一种传输性编码方案，按照UTF-8的方案，可以用1-4个字节的动态大小来存储Unicode。
//!     |    字符       |                   道                     |
//!     | Unicode码点   |  u+      9        0        5        3   |
//!     |              |       1001     0000     0101      0011  |
//!     | 编码⬇  解码⬆   |       1001        000001        010011  |
//!     |    UTF-8     |  1110 xxxx     10 xxxxxx     10 xxxxxx  |
//!     |              |     0xE9          0x81          0x93    |
//! UTF-8使用占位符机制保持编码属性的唯一性，确保即使传输过程中有字节损坏，也不会影响其它字符的正确性。
//!     0开头的字节，必为单字节字符 （此特性保证了UTF-8兼容ASCII码)
//!     10开头的字节，一定是附属字节
//!     110开头，表示本字符为2个字节，向后查找附属字节即可。
//!     1110开头，表示本字符为3个字节，向后查找附属字节即可。
//!     11110开头，表示本字符为4个字节，向后查找附属字节即可。
//!
//! Rust使用Unicode作为字符编码集。

#[test]
fn test_utf8() {
    let tao = String::from("\u{9053}"); //Rust下Unicode码的书写方式
    println!("{}", tao);

    let utf8_code: Vec<u8> = vec![0xE9, 0x81, 0x93];
    let tao = String::from_utf8(utf8_code).unwrap();
    println!("{}", tao);
}
