//! # 字符串
//!
//! # 字符串编码
//!
//! ## ASCII码
//! ASCII码，占用7bit，1byte，2位十六进制数即可表示：0x00-0x7F。可容纳128个字符，涵盖了英文字母，数字，常用符号，控制符号等。<br/>
//! 各国基于ASCII码扩展了自己的编码，但导致的问题是一旦跨国，就会出现乱码，因为编码被重复定义了。<br/>
//! 为了解决这个问题，让世界上的所有符号文字都有一个世界唯一的编码，Unicode诞生了。<br/>
//!
//! ## Unicode字符编码
//! Unicode占用2-4个字节，基本给全世界的文字和符号都定义了一个唯一的数字编码，称为码点。分别使用u+9053或u-99005533的形式标记。<br/>
//! Unicode仅定义了码点，对存储不做规定。且直接存储码点太占用空间，UTF-8随之诞生。<br/>
//!
//! ## UTF-8传输编码
//!     UTF-8是对Unicode码点的一种传输性编码方案，按照UTF-8的方案，可以用1-4个字节的动态大小来存储Unicode。
//!     汉字 '道' 的unicode编码为0x9053，使用utf-8的编解码示例：
//!     |       字符         |                   道                    |
//!     | Unicode码点(16进制)|  u+      9        0        5        3   |
//!     | Unicode码点(2进制) |       1001     0000     0101      0011  |
//!     |   编码⬇     解码⬆  |       1001        000001    010011      |
//!     |    UTF-8(2进制)   |  1110 1001     10 000001  10 010011     |
//!     |   UTF-8(16进制)   |     0xE9          0x81       0x93       |
//!
//! UTF-8使用占位符机制保持编码属性的唯一性，确保即使传输过程中有字节损坏，也不会影响其它字符的正确性。
//! -   0开头的字节，必为单字节字符 （此特性保证了UTF-8兼容ASCII码)
//! -   10开头的字节，一定是附属字节。
//! -   110开头，表示本字符为2个字节，向后查找附属字节即可。
//! -   1110开头，表示本字符为3个字节，向后查找附属字节即可。
//! -   11110开头，表示本字符为4个字节，向后查找附属字节即可。
//!
//! Rust使用Unicode作为字符编码集。其中char使用恒定4个字节存储字符的unicode编码，String使用utf-8方案用1-4个字节的动态大小来存储Unicode编码。


/// Rust 字符串编码演示
#[test]
fn test_utf8() {
    //汉字 '道' 的unicode编码为0x9053
    let tao = String::from("\u{9053}"); //Rust下Unicode码的书写方式
    println!("{}", tao);

    //汉字 '道' 的utf-8编码为0xE9 0x81 0x93
    let utf8_code: Vec<u8> = vec![0xE9, 0x81, 0x93];
    let tao = String::from_utf8(utf8_code).unwrap();
    println!("{}", tao);
}
